# 什么是算法的稳定性
当有两个有相等纪录R和S，且在原本的数组中R出现在S之前，在排序过后的数组中R也将会是在S之前，这种情况称之为排序算法是稳定的。

# 简单的排序
## 冒泡排序
1.核心思想: 在数组`无序区`中相邻位置上`比较和交换值`，使最大值如气泡一般逐渐往上"漂浮"直至"水面"。
2.数组的无序区逐渐缩小，有序区间逐渐扩大，无序区间在前，有序区间在后。
3.每一次循环后，在无序区中最大的那个值都会进入有序区，并成为有序区间的第一个元素。
4.如果数组的长度是 `n` ，那么第一次需要 `n-1` 次比较，第二次需要 `n-2` (因为无序区间变小了)，最后比较 `1` 次结束，因此时间复杂度是 `n-1 + n-2 + ... + 1`，为O(n*n)
5.算法是稳定的。
6.优化一: 如果在一次循环中没有进行交换，那么也就是说无序区已经变的有序了，因此可以终止整个排序过程了。
```go
func Bubble(a []int) {
	for i := 0; i < len(a); i++ {
		for j := 0; j < len(a)-i-1; j++ { // 无序区逐渐缩小，有序区逐渐增大
			if a[j] > a[j+1] { // 如果此处是 >= 那么就是不稳定的
				a[j],a[j+1]=a[j+1],a[j]
			}
		}
	}
}
```

## 插入排序
1.核心思想: 选择无序区中的第一个元素，插入有序区，插入的过程中通过`比较交换值`保证有序区的稳定。
2.数组的无序区逐渐缩小，有序区间逐渐扩大，有序区间在前，无序区间在后。
3.每一次循环后，有序区的长度都会加一，新加入的元素位置不定。
4.如果数组的长度是 `n` ，最坏的情况下，数组是逆序的，那么第一次需要 `1` 次交换，第二次需要 `2` 次 ，最后一次要比较 `n-1` 次结束，因此时间复杂度是 `1+2+...+ n-1`, 为O(n*n)
5.算法是稳定的。

```go
func Insert(a []int) {
	for i := 0; i < len(a)-1; i++ {  // 因为下一行的起始条件是j:=i+1,所以这里的终止条件是len(a)-1
		for j := i + 1; j > 0; j-- {
			if a[j] < a[j-1] {
				a[j-1],a[j]=a[j],a[j-1]
			}
		}
	}
}
```

## 选择排序
1.核心思想: 从无序区中选择出最小的元素放在新的有序区的末尾(和老的无序区的第一个元素交换)，有序区加一。
2.数组的无序区逐渐缩小，有序区间逐渐扩大，有序区间在前，无序区间再后。
3.每一次循环后，有序区的长度都会加一，新加入的元素一定在有序区的最后。
4.如果数组的长度是 `n` ，不论什么情况，第一次需要比较 `n-1` 次才能在无序区找到最小元素，第二次需要 `n-2` 次才能在无序区找到最小元素，最后需要 `1` 次，因此时间复杂度是 `n-1 + n-2 + ... + 1`
5.算法不稳定，因为每次循环都是在无序区中选择一个最小的数，和无序区中的第一个元素交换，假如无序区的第一个和第二个元素相等，经过循环，第一个元素会被置换到第二个元素后面。
```go
func Select(a []int) {
	for i := 0; i < len(a); i++ {
		minIndex := i
		for j := i; j < len(a); j++ {
			if a[j] < a[minIndex] {
				minIndex = j
			}
		}
		a[i],a[minIndex]=a[minIndex],a[i]
	}
}
```

## 希尔排序
1.核心思想: 是插入排序算法的一种改进，将序列按照一定的间隔分组，然后对每一组使用插入排序算法。
2.在希尔排序的理解时，我们倾向于对于每一个分组，逐组进行处理，但在代码实现中，我们可以不用这么按部就班地处理完一组再调转回来处理下一组，我们可以从第 `gap` 个元素开始，逐个跨组处理。
3.为什么希尔排序的效率高: 看似希尔排序比插入排序多了一层循环，但是在每一次对分组序列进行插入排序排序后，整个数组都倾向于有序了，这样会迅速的降低后续简单排序时交换的次数，从而降低复杂度。
4.算法不稳定。
5.冲破 `O(n*n)` 的第一批算法之一，时间复杂度 `O(nlogn)`。
```go
func Shell(a []int) {
	length := len(a)
	for inc := length / 2; inc > 0; inc = inc / 2 {
		for i := inc; i < length; i++ {
			for j := i - inc; j >= 0; j = j - inc {
				if a[j] > a[i] {
					a[j], a[i] = a[i], a[j]
				}
			}
		}
	}
}
```

### 归并排序
归并排序最重要的函数是 `merge` 函数,相较于堆排序和快速排序，归并排序是相对简单的。
- 合并左右序列到临时数组 `b` 中。
- 左右序列各一个扫描指针 `i,j`。
- 如果 `a[i]` 小于 `a[j]`，则 `b[t]=a[i]`，`i++`;否则 `b[t]=a[j]`，`j++`。
- 移动 `b数组` 的指针，`t++`。
- 当左序列已经扫描完毕，那么将右序列直接拷贝到临时数组。
- 当右序列已经扫描完毕，那么将左序列直接拷贝到临时数组。
- 将排序完的元素拷贝到原来的数组 `a` 中。
```go
func MergeSort(a, b []int, left, right int) {
	if left < right {
		mid := (left + right) / 2
		MergeSort(a, b, left, mid)
		MergeSort(a, b, mid+1, right)
		merge(a, b, left, mid, right)
	}
}

func merge(a, b []int, left, mid, right int) {
	i := left
	j := mid + 1
	t := 0
	for i <= mid && j <= right { // 左右序列扫描
		if a[i] < a[j] {
			b[t] = a[i]
			i++
		} else {
			b[t] = a[j]
			j++
		}
		t++
	}

	for i <= mid { // 当右序列已经扫描完毕，那么将左序列直接拷贝到临时数组
		b[t] = a[i]
		t++
		i++
	}

	for j <= right { // 当左序列已经扫描完毕，那么将右序列直接拷贝到临时数组
		b[t] = a[j]
		t++
		j++
	}

	t = 0
	for left <= right { // 将排序完的元素拷贝到原来的数组a中 ,注意拷贝到a数组中的位置
		a[left] = b[t]
		t++
		left++
	}
}
```

## 堆排序
堆是一种近似完全二叉树，下标为 `i` 的节点的(从 `0` 开始),有如下的性质:
- 父节点是 (i-1)/2
- 左孩子的节点是 i*2 + 1
- 右孩子的节点是 i*2 + 2
- 大(小)顶堆的父节点总是大(小)于子节点

首先需要调整初始化数组中的元素位置来构造一个大顶堆(以大顶堆为例)，在构造的过程中，我们就是需要用到上面的4个性质。
- heapify 是用来调整下标为i的节点，使得以其为根节点的树是一个大顶堆
- 对于整个数组，最后一个节点是`len(a)-1`，他的父节点是`len(a)/2-1`(计算方法参考性质1)，整个二叉树的调整就是从该节点开始的
```go
func HeapSort(a []int, n int) {
	for i := n/2 - 1; i >= 0; i-- { // 从最后一个节点(n-1)的父节点开始
		heapify(a, i, n)
	}

	for i := n - 1; i > 0; i-- {
		a[0], a[i] = a[i], a[0]
		heapify(a, 0, i) // 因为第0个节点被调换了位置，那么需要调整，保持为大顶堆
	}
}

func heapify(a []int, i, n int) {
	largest := i
	lson := 2*i + 1 // 堆的性质
	rson := 2*i + 2 // 堆的性质

	// 选择出i节点和左右子节点中哪个位置的值最大
	if lson < n && a[largest] < a[lson] {
		largest = lson
	}

	if rson < n && a[largest] < a[rson] {
		largest = rson
	}

	// 如果最大的节点不是i节点，那么需要将i节点的值和largest节点的值做调换
	if largest != i {
		a[largest], a[i] = a[i], a[largest] // go快速交换元素的语法糖
		// 递归调用，使得largest节点也满足大顶堆的性质(因为调整过后largest节点可能不满足大顶堆性质)
		heapify(a, largest, n)
	}
}
```

## 快速排序
- 快速排序采用的是分治的思想
- 快速排序最重要的函数就是分区函数`partition`
- 分区函数的目的是，找到`pivot`在序列中的正确位置，使得左边的元素都小于它，右边的元素都大于它
- 选出最后一个元素作为`pivot`
- 先利用一个左指针从左向右扫描序列，当左指针指向的元素`a[i]`大于`pivot`时停止扫描(这意味着`a[i]`元素的位置不正确需要调换)
- 再利用一个右指针从右向左扫描序列，当右指针指向的元素`a[j]`小于`pivot`时停止扫描(这意味着`a[j]`元素的位置不正确需要调换)
- 调换`a[i]`,`a[j]`
- 继续按照上述逻辑进行扫描，终止的条件是i=j，此时就到了`pivot`再序列中的位置
- 将`pivot`元素放置在i的位置
```go
func QuickSort(a []int, low, high int) {
	if low < high {
		mid := partition(a, low, high)
		QuickSort(a, low, mid-1)
		QuickSort(a, mid+1, high)
	}
}

func partition(a []int, low, high int) int {
	pivot := high
	i := low  // 左指针
	j := high // 右指针

	for i != j {
		for i < j && a[i] <= a[pivot] { // 从左边开始扫描
			i++
		}
		for i < j && a[j] >= a[pivot] {
			j--
		}
		a[i], a[j] = a[j], a[i] // 交换元素
	}
	a[i], a[pivot] = a[pivot], a[i] // pivot放置在最终的位置上
	return i
}
```